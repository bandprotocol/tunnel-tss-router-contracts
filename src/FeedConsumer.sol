// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./BandTssBridge.sol";

abstract contract FeedConsumer is BandTssBridge {
    // A signal price from bandchain.
    struct SignalPrice {
        string SignalID;
        uint64 Price;
    }
    // A feeds price Result from bandchain.
    struct FeedsPriceData {
        SignalPrice[] SignalPrices;
        int64 timestamp;
    }
    // signalID to feeds price data
    mapping(uint => FeedsPriceData) private SigningIDToFeedsPriceData;

    event RelayFeedsPriceResult(uint64 indexed signingID);

    /// @dev relay the oracle result and store it in the chain
    /// @param rAddress is the address form of the commitment R
    /// @param s represents the Schnorr signature generated by the current circle's private key
    /// @param result is the oracle result from bandchain
    function relayFeedsPriceData(
        address rAddress,
        uint256 s,
        uint64 signingID,
        bytes memory result
    ) external {
        bytes32 msgHash = keccak256(abi.encodePacked(result));
        require(
            verify(rAddress, s, msgHash),
            "FeedConsumer: Public key update fails, the current circle's signature is invalid."
        );

        SignalPrice[] memory sp;
        int64 timestamp;
        (sp, timestamp) = abi.decode(
            (slice(result, 8, result.length - 8)),
            (SignalPrice[], int64)
        );

        FeedsPriceData storage feedsPriceData = SigningIDToFeedsPriceData[
            signingID
        ];
        delete feedsPriceData.SignalPrices;
        for (uint256 i = 0; i < sp.length; i++) {
            feedsPriceData.SignalPrices.push(sp[i]);
        }
        feedsPriceData.timestamp = timestamp;

        emit RelayFeedsPriceResult(signingID);
    }

    /// @dev get the feeds price data from the chain
    /// @param signingID is the signing ID of the feeds price data
    /// @return SignalPrice array and the timestamp of the feeds price data
    function getFeedsPriceData(
        uint64 signingID
    ) external view returns (SignalPrice[] memory, int64) {
        FeedsPriceData storage feedsPriceData = SigningIDToFeedsPriceData[
            signingID
        ];
        return (feedsPriceData.SignalPrices, feedsPriceData.timestamp);
    }

    /// @dev slice the bytes data
    /// @param data is the bytes data
    /// @param start is the start index
    /// @param len is the length of the slice
    function slice(
        bytes memory data,
        uint start,
        uint len
    ) internal pure returns (bytes memory) {
        bytes memory b = new bytes(len);

        for (uint i = 0; i < len; i++) {
            b[i] = data[i + start];
        }

        return b;
    }
}
