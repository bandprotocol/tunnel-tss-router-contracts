// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract BandTssBridgeConsumer {
    // The group order of secp256k1
    uint256 public constant ORDER =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    // The prefix for the oracle result message
    bytes8 ORACLE_RESULT_PREFIX = 0x89cbf5af45b4e7ea;
    // The prefix for the hashing process in bandchain
    string constant CONTEXT = "BAND-TSS-secp256k1-v0";
    // The prefix for the challenging hash message
    string constant CHALLENGE_PREFIX = "challenge";
    // A prefix that represents the key operation update
    uint8 public constant UPDATE_KEY_OPERATION_PREFIX = 0;

    // The current circle's public key's parity value
    uint8 public parity;
    // The x-coordinate of the current circle's public key
    uint256 public px;

    // type of encoding of the oracle result
    enum OracleTssEncodeType {
        UNDEFINED,
        PROTO,
        FULL_ABI,
        PARTIAL_ABI
    }

    // An oracle result from bandchain, the order of the fields is the same as the ABI encoding
    // defined in tss package.
    struct OracleResult {
        string ClientID;
        uint64 OracleScriptID;
        bytes Calldata;
        uint64 AskCount;
        uint64 MinCount;
        uint64 RequestID;
        uint64 AnsCount;
        int64 RequestTime;
        int64 ResolveTime;
        int32 ResolveStatus;
        bytes Result;
    }

    // requestID to oracle result
    mapping(uint => OracleResult) public OracleResults;
    // requestID to request type
    mapping(uint => OracleTssEncodeType) public OracleRequestTypes;

    event RelayOracleResult(
        uint64 indexed requestID,
        uint64 indexed OracleScriptID,
        OracleTssEncodeType encodeType
    );
    event UpdateGroupPubKey(uint8 parity, uint256 px);

    constructor(uint8 _parity, uint256 _px) {
        parity = _parity + 25;
        px = _px;
    }

    /// @param _parity is the parity value of the new public key
    /// @param rAddress is the address form of the commitment R
    /// @param _px is the x-coordinate value of the new public key
    /// @param s represents the Schnorr signature generated by the current circle's private key
    function updatePubkey(
        uint8 _parity,
        address rAddress,
        uint256 _px,
        uint256 s
    ) external {
        require(
            verify(
                rAddress,
                s,
                keccak256(
                    abi.encodePacked(UPDATE_KEY_OPERATION_PREFIX, _parity, _px)
                )
            ),
            "BandTssBridgeConsumer: Public key update fails, the current circle's signature is invalid."
        );
        parity = _parity + 25;
        px = _px;

        emit UpdateGroupPubKey(parity, px);
    }

    /// @dev relay the oracle result and store it in the chain
    /// @param rAddress is the address form of the commitment R
    /// @param s represents the Schnorr signature generated by the current circle's private key
    /// @param result is the oracle result from bandchain
    function relayFullAbi(
        address rAddress,
        uint256 s,
        OracleResult memory result
    ) external {
        bytes32 msgHash = keccak256(
            abi.encodePacked(ORACLE_RESULT_PREFIX, abi.encode(result))
        );
        require(
            verify(rAddress, s, msgHash),
            "BandTssBridgeConsumer: Public key update fails, the current circle's signature is invalid."
        );

        OracleResults[result.RequestID] = result;
        OracleRequestTypes[result.RequestID] = OracleTssEncodeType.FULL_ABI;

        emit RelayOracleResult(
            result.RequestID,
            result.OracleScriptID,
            OracleTssEncodeType.FULL_ABI
        );
    }

    /// @param rAddress is the address form of the commitment R
    /// @param s represents the Schnorr signature generated by the current circle's private key
    /// @param messageHash is the hash from the original message
    function verify(
        address rAddress,
        uint256 s,
        bytes32 messageHash
    ) public view returns (bool) {
        require(
            rAddress != address(0),
            "BandTssBridgeConsumer: Invalid address of R"
        );

        uint8 _parity = parity;
        uint256 _px = px;

        uint256 c = uint256(
            keccak256(
                abi.encodePacked(
                    CONTEXT,
                    bytes1(0x00),
                    CHALLENGE_PREFIX,
                    bytes1(0x00),
                    rAddress,
                    _parity,
                    _px,
                    messageHash
                )
            )
        );

        uint256 spx = ORDER - mulmod(s, _px, ORDER);
        uint256 cpx = ORDER - mulmod(c, _px, ORDER);

        // Because the ecrecover precompile implementation verifies that the 'r' and's'
        // input positions must be non-zero
        // So in this case, there is no need to verify them('px' > 0 and 'cpx' > 0).
        require(spx != 0, "BandTssBridgeConsumer: Invalid value of s*px");

        return
            rAddress ==
            ecrecover(bytes32(spx), _parity, bytes32(_px), bytes32(cpx));
    }
}
