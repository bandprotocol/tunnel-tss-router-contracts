pragma solidity ^0.8.0;

contract FutureBridge {
	// The group order of secp256k1
	uint256 public constant ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;

	// A hash that represents the key operation update
	bytes32 public constant UPDATE_KEY_OPERATION_HASH = keccak256(bytes("UPDATE_KEY_OPERATION_HASH"));

	// The current circle's public key's parity value
	uint8 public parity;
	// The x-coordinate of the current circle's public key
	uint256 public px;

	constructor(uint8 _parity, uint256 _px) {
		parity = _parity;
		px = _px;
	}

	// @param _parity is the parity value of the new public key
	// @param rAddress is the address form of the commitment R
	// @param _px is the x-coordinate value of the new public key
	// @param s represents the Schnorr signature generated by the current circle's private key
	function updatePubkey(uint8 _parity, address rAddress, uint256 _px, uint256 s) external {
		require(
			verify(rAddress, s, keccak256(abi.encodePacked(UPDATE_KEY_OPERATION_HASH, _parity, _px))),
			"FutureBridge: Public key update fails, the current circle's signature is invalid."
		);
		parity = _parity;
		px = _px;
	}

	// @param rAddress is the address form of the commitment R
	// @param s represents the Schnorr signature generated by the current circle's private key
	// @param messageHash is the hash from the original message
	function verify(address rAddress, uint256 s, bytes32 messageHash) public view returns (bool) {
		require(rAddress != address(0), "FutureBridge: Invalid address of R");

		uint8 _parity = parity;
		uint256 _px = px;

		uint256 c = uint256(keccak256(abi.encodePacked(
            bytes32(0x42414e442d5453532d736563703235366b312d7630006368616c6c656e676500),
            rAddress,
            _parity,
            _px,
            messageHash
        )));

		uint256 spx = ORDER - mulmod(s, _px, ORDER);
		uint256 cpx = ORDER - mulmod(c, _px, ORDER);

		// Because the ecrecover precompile implementation verifies that the 'r' and's'
		// input positions must be non-zero
		// So in this case, there is no need to verify them('px' > 0 and 'cpx' > 0).
		require(spx != 0, "FutureBridge: Invalid value of s*px");

		return rAddress == ecrecover(bytes32(spx), _parity, bytes32(_px), bytes32(cpx));
	}
}
