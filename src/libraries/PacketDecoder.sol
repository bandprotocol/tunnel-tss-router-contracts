// SPDX-License-Identifier: MIT

pragma solidity ^0.8.23;

library PacketDecoder {
    bytes4 private constant _FIXED_POINT_ENCODER_SELECTOR = 0xcba0ad5a; // keccak256("FixedPointABI");
    bytes4 private constant _TICK_ENCODER_SELECTOR = 0xdb99b2b3; // keccak256("TickABI");

    enum EncoderType {
        Unidentified,
        FixedPoint,
        Tick
    }

    // info of signals being published in the packet.
    struct SignalPrice {
        bytes32 signal;
        uint64 price;
    }

    // the packet information generated from the tunnel.
    struct Packet {
        uint64 tunnelId;
        uint64 sequence;
        string chainId;
        string targetAddr;
        SignalPrice[] signals;
        int64 timestamp;
    }

    // the TSS message structure that is generated by the tunnel and is signed by the tss module.
    struct TssMessage {
        bytes32 hashOriginator;
        uint64 sourceBlocktimestamp;
        uint64 signingId;
        EncoderType encoderType;
        Packet packet;
    }

    /**
     * @dev Decode the TSS message from the encoded message.
     * @param message The encoded message.
     * @return TssMessage The decoded TSS message object.
     */
    function decodeTssMessage(
        bytes calldata message
    ) internal pure returns (TssMessage memory) {
        EncoderType encoder = _toEncoderType(bytes4(message[52:56]));

        Packet memory packet = _decodePacket(message);

        TssMessage memory tssMessage = TssMessage(
            bytes32(message[0:32]),
            uint64(bytes8(message[32:40])),
            uint64(bytes8(message[40:48])),
            encoder,
            packet
        );

        return tssMessage;
    }

    /**
     * @dev Decode the TSS message from the encoded message.
     * @param message The encoded message.
     * @return TssMessage The decoded TSS message object.
     */
    function _decodePacket(
        bytes calldata message
    ) internal pure returns (Packet memory) {
        Packet memory packet = abi.decode(message[56:], (Packet));
        return packet;
    }

    /**
     * @dev Convert the selector to the encoder type.
     * @param selector The selector to be converted.
     * @return EncoderType The encoder type.
     */
    function _toEncoderType(
        bytes4 selector
    ) internal pure returns (EncoderType) {
        if (selector == _FIXED_POINT_ENCODER_SELECTOR) {
            return EncoderType.FixedPoint;
        } else if (selector == _TICK_ENCODER_SELECTOR) {
            return EncoderType.Tick;
        } else {
            return EncoderType.Unidentified;
        }
    }
}
