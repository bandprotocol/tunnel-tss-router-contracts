// SPDX-License-Identifier: MIT

pragma solidity ^0.8.23;

library PacketDecoder {
    bytes8 private constant _FIXED_POINT_ENCODER_SELECTOR = 0xd3813e0ccba0ad5a; // keccak256("tunnel")[:4] + keccak256("FixedPointABI")[:4];
    bytes8 private constant _TICK_ENCODER_SELECTOR = 0xd3813e0cdb99b2b3; // keccak256("tunnel")[:4] + keccak256("TickABI")[:4];

    enum EncoderType {
        Undefined,
        FixedPoint,
        Tick
    }

    // info of signals being published in the packet.
    struct SignalPrice {
        bytes32 signal;
        uint64 price;
    }

    // the packet information generated from the tunnel.
    struct Packet {
        uint64 tunnelId;
        uint64 sequence;
        string chainId;
        string targetAddr;
        SignalPrice[] signals;
        int64 timestamp;
    }

    // the TSS message structure that is generated by the tunnel and is signed by the tss module.
    struct TssMessage {
        bytes32 hashOriginator;
        uint64 sourceBlocktimestamp;
        uint64 signingId;
        EncoderType encoderType;
        Packet packet;
    }

    /**
     * @dev Decode the TSS message from the encoded message.
     * @param message The encoded message.
     * @return TssMessage The decoded TSS message object.
     */
    function decodeTssMessage(bytes calldata message) internal pure returns (TssMessage memory) {
        EncoderType encoder = _toEncoderType(bytes8(message[48:56]));

        Packet memory packet = _decodePacket(message);

        TssMessage memory tssMessage = TssMessage(
            bytes32(message[0:32]), uint64(bytes8(message[32:40])), uint64(bytes8(message[40:48])), encoder, packet
        );

        return tssMessage;
    }

    /**
     * @dev Decode the TSS message from the encoded message.
     * @param message The encoded message.
     * @return TssMessage The decoded TSS message object.
     */
    function _decodePacket(bytes calldata message) internal pure returns (Packet memory) {
        Packet memory packet = abi.decode(message[56:], (Packet));
        return packet;
    }

    /**
     * @dev Convert the selector to the encoder type.
     * @param selector The selector to be converted.
     * @return EncoderType The encoder type.
     */
    function _toEncoderType(bytes8 selector) internal pure returns (EncoderType) {
        if (selector == _FIXED_POINT_ENCODER_SELECTOR) {
            return EncoderType.FixedPoint;
        } else if (selector == _TICK_ENCODER_SELECTOR) {
            return EncoderType.Tick;
        } else {
            return EncoderType.Undefined;
        }
    }
}
