// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

abstract contract BandTssBridge {
    // The group order of secp256k1
    uint256 public constant ORDER =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    // The prefix for the key update message.
    bytes8 UPDATE_KEY_PREFIX = 0x135e4b6353a9c808;
    // The prefix for the hashing process in bandchain
    string constant CONTEXT = "BAND-TSS-secp256k1-v0";
    // The prefix for the challenging hash message
    string constant CHALLENGE_PREFIX = "challenge";
    // The current circle's public key's parity value
    uint8 public parity;
    // The x-coordinate of the current circle's public key
    uint256 public px;

    event UpdateGroupPubKey(uint8 parity, uint256 px);

    constructor(uint8 _parity, uint256 _px) {
        parity = _parity + 25;
        px = _px;
    }

    /// @param _parity is the parity value of the new public key
    /// @param rAddress is the address form of the commitment R
    /// @param _px is the x-coordinate value of the new public key
    /// @param s represents the Schnorr signature generated by the current circle's private key
    function updatePubkey(
        uint8 _parity,
        address rAddress,
        uint256 _px,
        uint256 s
    ) external {
        require(
            verify(
                rAddress,
                s,
                keccak256(abi.encodePacked(UPDATE_KEY_PREFIX, _parity, _px))
            ),
            "BandTssBridge: Public key update fails, the current circle's signature is invalid."
        );
        parity = _parity + 25;
        px = _px;

        emit UpdateGroupPubKey(parity, px);
    }

    /// @param rAddress is the address form of the commitment R
    /// @param s represents the Schnorr signature generated by the current circle's private key
    /// @param messageHash is the hash from the original message
    function verify(
        address rAddress,
        uint256 s,
        bytes32 messageHash
    ) public view returns (bool) {
        require(rAddress != address(0), "BandTssBridge: Invalid address of R");

        uint8 _parity = parity;
        uint256 _px = px;

        uint256 c = uint256(
            keccak256(
                abi.encodePacked(
                    CONTEXT,
                    bytes1(0x00),
                    CHALLENGE_PREFIX,
                    bytes1(0x00),
                    rAddress,
                    _parity,
                    _px,
                    messageHash
                )
            )
        );

        uint256 spx = ORDER - mulmod(s, _px, ORDER);
        uint256 cpx = ORDER - mulmod(c, _px, ORDER);

        // Because the ecrecover precompile implementation verifies that the 'r' and's'
        // input positions must be non-zero
        // So in this case, there is no need to verify them('px' > 0 and 'cpx' > 0).
        require(spx != 0, "BandTssBridge: Invalid value of s*px");

        return
            rAddress ==
            ecrecover(bytes32(spx), _parity, bytes32(_px), bytes32(cpx));
    }
}
